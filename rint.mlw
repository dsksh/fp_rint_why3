
module RealInterval
  use real.Real
  use real.Abs
  use ieee_float.Float64
  use export ieee_float.RoundingMode

  val constant max_real : real
    ensures { result = Float64.max_real }
  val constant large_real : real
    ensures { result > max_real * max_real }

  val constant err_denom : real
  val constant err_min : real

  type t = { l : real; u : real; p_nan : bool }

  (* Assume only "ordered" intervals. *)
  (*axiom order: forall t. t.l <= t.u*)

  predicate ordered (x:t) = x.l <= x.u

  let constant zeroI : t = { l=0.; u=0.; p_nan=false }
  let constant zero_nan : t = { l=0.; u=0.; p_nan=true }

  let predicate is_ninf_s_ (x:real) = x <= (- large_real)
  let predicate is_pinf_s_ (x:real) = x >= large_real
  let predicate is_inf_s_ (x:real) = is_ninf_s_ x || is_pinf_s_ x

  let predicate is_ninf_s (x:t) = is_ninf_s_ x.l
  let predicate is_pinf_s (x:t) = is_pinf_s_ x.u
  let predicate is_inf_s (x:t) = is_ninf_s x || is_pinf_s x

  let predicate is_ninf_ (x:real) = x < (- max_real)
  let predicate is_pinf_ (x:real) = x > max_real
  let predicate is_inf_ (x:real) = is_ninf_ x || is_pinf_ x

  let predicate is_ninf (x:t) = is_ninf_ x.l
  let predicate is_pinf (x:t) = is_pinf_ x.u
  let predicate is_inf (x:t) = is_ninf x || is_pinf x

  let predicate diff_sgn (x:real) (y:real) = (x >= 0. && y < 0.) || (x < 0. && y >= 0.)

  let function r_dn (v:real)
    ensures { result <= round RTN v }
    ensures { forall m. result <= round m v }
    ensures { forall m. (round m v) < (- max_real) -> result = (- large_real) }
  = let w = v - ((if v >= 0. then v else -v) / err_denom) - err_min in
    if w >= -max_real then w else -large_real

  let function r_up (v:real)
    ensures { result >= round RTP v }
    ensures { forall m. result >= round m v }
    ensures { forall m. (round m v) > max_real -> result = large_real }
  = let w = v + ((if v >= 0. then v else -v) / err_denom) + err_min in
    if w <= max_real then w else large_real

  predicate fp_in_ri (xx:Float64.t) (x:t)
  = (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) /\
    (is_minus_infinity xx -> x.l <= (- large_real)) /\
    (is_plus_infinity xx -> x.u >= large_real) /\
    (is_nan xx -> x.p_nan)

end

module Addition
  use real.Real
  use ieee_float.Float64
  use RealInterval

  let op (x y : t) : t
    requires { ordered x /\ ordered y }
    ensures { ordered result }

    (*ensures { forall xx. forall yy. 
      (*(t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->*)
      (x.l <= t'real xx /\ t'real xx <= x.u) ->
      (y.l <= t'real yy /\ t'real yy <= y.u) ->
      result.l <= (t'real xx) + (t'real yy) /\ (t'real xx) + (t'real yy) <= result.u }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      no_overflow RNE (t'real xx + t'real yy) ->
      t'isFinite (xx .+ yy) -> 
      result.l <= t'real (xx .+ yy) /\ t'real (xx .+ yy) <= result.u }

    ensures { forall xx. forall yy. (*fp_in_ri xx x -> fp_in_ri yy y ->*)
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_minus_infinity (xx .+ yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy. (*fp_in_ri xx x -> fp_in_ri yy y ->*)
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_plus_infinity (xx .+ yy) -> result.u = large_real }

    ensures { forall xx. forall yy. (*fp_in_ri xx x -> fp_in_ri yy y ->*)
      (is_nan xx -> x.p_nan) -> (is_nan yy -> x.p_nan) -> 
      (is_plus_infinity xx -> is_pinf x) -> (is_minus_infinity xx -> is_ninf x) -> 
      (is_plus_infinity yy -> is_pinf y) -> (is_minus_infinity yy -> is_ninf y) ->
      is_nan (xx .+ yy) -> result.p_nan }
    *)

    ensures { forall xx. forall yy. fp_in_ri xx x -> fp_in_ri yy y ->
      fp_in_ri (xx .+ yy) result }

  = let l = r_dn (x.l + y.l) in
    let u = r_up (x.u + y.u) in
    let p_nan = x.p_nan || y.p_nan || 
      (is_ninf x && is_pinf y) || (is_pinf x && is_ninf y) in
    assert { l <= u };
    (*assert { l <= round RTN (x.l + y.l) };
    assert { u >= round RTP (x.u + y.u) };*)
    assert { l <= round RNE (x.l + y.l) };
    assert { u >= round RNE (x.u + y.u) };
    (*assert { forall m. l <= round m (x.l + y.l) };
    assert { forall m. u >= round m (x.u + y.u) };*)
    (*assert { forall m. (round m (x.l + y.l)) < (- max_real) -> l < (- max_real) };
    assert { forall m. (round m (x.u + y.u)) > max_real -> u > max_real };*)
    assert { forall m. (round m (x.l + y.l)) < (- max_real) -> l = (- large_real) };
    assert { forall m. (round m (x.u + y.u)) > max_real -> u = large_real };
    { l = l; u = u; p_nan = p_nan }

end

module Subtraction
  use real.Real
  use ieee_float.Float64
  use RealInterval

  let op (x:t) (y:t)
    requires { ordered x /\ ordered y }
    ensures { ordered result }

    (*
    ensures { forall xx. forall yy. 
      (x.l <= t'real xx /\ t'real xx <= x.u) ->
      (y.l <= t'real yy /\ t'real yy <= y.u) ->
      result.l <= (t'real xx) - (t'real yy) /\ (t'real xx) - (t'real yy) <= result.u }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      no_overflow RNE (t'real xx - t'real yy) ->
      t'isFinite (xx .- yy) -> 
      result.l <= t'real (xx .- yy) /\ t'real (xx .- yy) <= result.u }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_minus_infinity (xx .- yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_plus_infinity (xx .- yy) -> result.u = large_real } 

    ensures { forall xx. forall yy.
      (is_nan xx -> x.p_nan) -> (is_nan yy -> x.p_nan) -> 
      (is_plus_infinity xx -> is_pinf x) -> (is_minus_infinity xx -> is_ninf x) -> 
      (is_plus_infinity yy -> is_pinf y) -> (is_minus_infinity yy -> is_ninf y) ->
      is_nan (xx .- yy) -> result.p_nan }
    *)

    ensures { forall xx. forall yy. fp_in_ri xx x -> fp_in_ri yy y ->
      fp_in_ri (xx .- yy) result
    }

  = let l_ = r_dn (x.l - y.u) in
    let u = r_up (x.u - y.l) in
    let p_nan = x.p_nan || y.p_nan || 
      (is_ninf x && is_ninf y) || (is_pinf x && is_pinf y) in
    assert { l_ <= u };
    assert { l_ <= round RNE (x.l - y.u) };
    assert { u >= round RNE (x.u - y.l) };
    assert { forall m. (round m (x.l - y.u)) < (- max_real) -> l_ = (- large_real) };
    assert { forall m. (round m (x.u - y.l)) > max_real -> u = large_real };
    { l = l_; u = u; p_nan = p_nan }

end

module Multiplication
  use real.Real
  use ieee_float.Float64
  use RealInterval
  use rineq.RmultLeCompat

  (* Auxiliary lemmas. *)

  lemma mult_fin_ninf: forall xx yy.
    t'isFinite xx -> t'isFinite yy -> is_minus_infinity (mul RTN xx yy) ->
    round RTN (t'real xx * t'real yy) < (- max_real)

  lemma mult_ninf_conds: forall xx yy.
    is_minus_infinity (mul RTN xx yy) ->
    ( t'isFinite xx /\ t'isFinite yy /\
      round RTN (t'real xx * t'real yy) < (- max_real) ) \/
    (t'isFinite xx /\ t'real xx > 0. /\ is_minus_infinity yy) \/
    (t'isFinite xx /\ t'real xx < 0. /\ is_plus_infinity yy) \/
    (is_minus_infinity xx /\ t'isFinite yy /\ t'real yy > 0.) \/
    (is_plus_infinity xx  /\ t'isFinite yy /\ t'real yy < 0.) \/
    (is_minus_infinity xx /\ is_plus_infinity yy) \/
    (is_plus_infinity xx  /\ is_minus_infinity yy)

  lemma mult_fin_pinf: forall xx yy.
    t'isFinite xx -> t'isFinite yy -> is_plus_infinity (mul RTP xx yy) ->
    round RTP (t'real xx * t'real yy) > max_real

  lemma mult_pinf_conds: forall xx yy.
    is_plus_infinity (mul RTP xx yy) ->
    ( t'isFinite xx /\ t'isFinite yy /\
      round RTP (t'real xx * t'real yy) > max_real ) \/
    (t'isFinite xx /\ t'real xx < 0. /\ is_minus_infinity yy ) \/
    (t'isFinite xx /\ t'real xx > 0. /\ is_plus_infinity yy) \/
    (is_minus_infinity xx /\ t'isFinite yy /\ t'real yy < 0.) \/
    (is_plus_infinity xx  /\ t'isFinite yy /\ t'real yy > 0.) \/
    (is_minus_infinity xx /\ is_minus_infinity yy) \/
    (is_plus_infinity xx  /\ is_plus_infinity yy)

  lemma mult_nan_conds: forall xx yy. forall m.
    is_nan (mul m xx yy) ->
    (is_nan xx \/ is_nan yy) \/
    (is_zero xx /\ is_infinite yy) \/
    (is_infinite xx /\ is_zero yy)

  (*lemma mult_bnd: forall x y. in_range x -> in_range y ->
    - large_real < x * y /\ x * y < large_real*)

  (* Operator definition. *)

  let op (x y : t) : t
    requires { ordered x /\ ordered y }
    requires { - large_real <= x.l /\ x.u <= large_real }
    requires { - large_real <= y.l /\ y.u <= large_real }

    ensures { ordered result }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      no_overflow RTN (t'real xx * t'real yy) ->
      t'isFinite (mul RTN xx yy) -> result.l <= t'real (mul RTN xx yy) }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      no_overflow RTP (t'real xx * t'real yy) ->
      t'isFinite (mul RTP xx yy) -> t'real (mul RTP xx yy) <= result.u }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      (*round RTN (t'real xx * t'real yy) < (- max_real) -> result.l = (- large_real)*)
      is_minus_infinity (mul RTN xx yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_minus_infinity (mul RTN xx yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      is_plus_infinity (mul RTP xx yy) -> result.u = large_real }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_plus_infinity (mul RTP xx yy) -> result.u = large_real } 

    ensures { forall xx. forall yy.
      (is_nan xx -> x.p_nan) -> (is_nan yy -> x.p_nan) -> 
      (is_zero xx -> x.l <= 0. /\ 0. <= x.u) ->
      (is_zero yy -> y.l <= 0. /\ 0. <= y.u) ->
      (is_plus_infinity xx -> is_pinf x) -> (is_minus_infinity xx -> is_ninf x) -> 
      (is_plus_infinity yy -> is_pinf y) -> (is_minus_infinity yy -> is_ninf y) ->
      is_nan (mul RNE xx yy) -> result.p_nan }

    ensures { forall xx. forall yy. fp_in_ri xx x -> fp_in_ri yy y ->
      (is_zero xx -> x.l <= 0. /\ 0. <= x.u) ->
      (is_zero yy -> y.l <= 0. /\ 0. <= y.u) ->

      (*fp_in_ri (xx .* yy) result*)

      ( no_overflow RTN (t'real xx * t'real yy) ->
        t'isFinite (mul RTN xx yy) -> result.l <= t'real (mul RTN xx yy) ) /\ 
      ( no_overflow RTP (t'real xx * t'real yy) ->
        t'isFinite (mul RTP xx yy) -> t'real (mul RTP xx yy) <= result.u ) /\
      (is_minus_infinity (mul RTN xx yy) -> result.l <= (- large_real)) /\
      (is_plus_infinity (mul RTP xx yy) -> result.u >= large_real) /\
      (is_nan (mul RNE xx yy) -> result.p_nan)
    }

  = if x.l >= 0. then
      if x.u = 0. then
        if not is_ninf y && not is_pinf y then
          (* [x] = [0] *)
          if not x.p_nan && not y.p_nan then zeroI else zero_nan
        else
          (* [x] = [0] and (-inf = [y] or [y] = +inf) *)
          zero_nan

      else 
        if y.l >= 0. then
          if y.u = 0. then
            (* 0 <= [x] and [x] != [0] and [y] = [0] *)
            if not is_pinf x then
              if not x.p_nan && not y.p_nan then zeroI else zero_nan
            else 
              zero_nan
          else begin
            (* 0 <= [x] and [x] != [0] and 0 <= [y] and [y] != [0] *)
            assert { 0. <= x.l /\ 0. < x.u /\ 0. <= y.l /\ 0. < y.u };
            assert { not is_ninf x /\ not is_ninf y };
            let l_ = r_dn (x.l * y.l) in
            let u_ = if is_pinf x || is_pinf y then large_real else r_up (x.u * y.u) in
            let p_nan = x.p_nan || y.p_nan || (x.l = 0. && is_pinf y) || (is_pinf x && y.l = 0.) in
              (*assert { x.l*y.l <= x.u*y.u };*)
              assert { l_ <= u_ };
              assert { forall m. l_ <= round m (x.l * y.l) };
              assert { forall m. u_ >= round m (x.u * y.u) };
              assert { l_ <= round RTN (x.l * y.l) };
              assert { u_ >= round RTP (x.u * y.u) };
              assert { forall m. (round m (x.l * y.l)) < (- max_real) -> l_ = (- large_real) };
              assert { forall m. (round m (x.u * y.u)) > max_real -> u_ = large_real };
              assert { round RTN (x.l * y.l) < (- max_real) -> l_ = (- large_real) };
              assert { round RTP (x.u * y.u) > max_real -> u_ = large_real };
              (*assert { x.l * y.l >= 0. };*)
              { l=l_; u=u_; p_nan=p_nan }
          end

        else if y.u <= 0. then begin
          (* 0 <= [x] and [x] != [0] and [y] <= 0 and [y] != [0] *)
          assert { 0. <= x.l /\ 0. < x.u /\ y.u <= 0. /\ y.l < 0. };
          let l_ = if is_pinf x || is_ninf y then - large_real else r_dn (x.u * y.l) in
          let u_ = r_up (x.l * y.u) in
          let p_nan = x.p_nan || y.p_nan || (x.l = 0. && is_ninf y) || (is_pinf x && y.u = 0.) in
            assert { l_ <= u_ };
            assert { forall m. l_ <= round m (x.u * y.l) };
            assert { forall m. u_ >= round m (x.l * y.u) };
            assert { l_ <= round RTN (x.u * y.l) };
            assert { u_ >= round RTP (x.l * y.u) };
            assert { forall m. (round m (x.u * y.l)) < (- max_real) -> l_ = (- large_real) };
            assert { forall m. (round m (x.l * y.u)) > max_real -> u_ = large_real };
            { l=l_; u=u_; p_nan=p_nan }
            (* TODO *)
        end
        else begin
          (* 0 <= [x] and [x] != [0] and [y] strictly contains 0 *)
          assert { 0. <= x.l /\ 0. < x.u /\ y.l < 0. /\ 0. < y.u };
          let l_ = if is_pinf x || is_ninf y then - large_real else r_dn (x.u * y.l) in
          let u_ = if is_pinf x || is_pinf y then large_real else r_up (x.u * y.u) in
          let p_nan = x.p_nan || y.p_nan || is_pinf x || (x.l = 0. && (is_ninf y || is_pinf y)) in
            assert { l_ <= u_ };
            assert { forall m. l_ <= round m (x.u * y.l) };
            assert { forall m. u_ >= round m (x.u * y.u) };
            assert { l_ <= round RTN (x.u * y.l) };
            assert { u_ >= round RTP (x.u * y.u) };
            assert { forall m. (round m (x.u * y.l)) < (- max_real) -> l_ = (- large_real) };
            assert { forall m. (round m (x.u * y.u)) > max_real -> u_ = large_real };
            { l=l_; u=u_; p_nan=p_nan }
        end
    else 
      if x.u <= 0. then
        if y.l >= 0. then
          if not is_pinf y && y.u = 0. then
            (* [x] <= 0 and [x] != [0] and [y] = [0] *)
            if not is_ninf x then
              if not x.p_nan && not y.p_nan then zeroI else zero_nan
            else
              zero_nan
          else begin
            (* [x] <= 0 and [x] != [0] and 0 <= [y] and [y] != [0] *)
            assert { x.l < 0. /\ x.u <= 0. /\ 0. <= y.l /\ 0. < y.u };
            assert { not is_pinf x /\ not is_ninf y };
            let l_ = if is_ninf x || is_pinf y then -large_real else r_dn (x.l * y.u) in
            let u_ = r_up (x.u * y.l) in
            let p_nan = x.p_nan || y.p_nan || (x.u = 0. && is_pinf y) || (is_ninf x && y.l = 0.) in
              assert { l_ <= u_ };
              assert { forall m. l_ <= round m (x.l * y.u) };
              assert { forall m. u_ >= round m (x.u * y.l) };
              assert { l_ <= round RTN (x.l * y.u) };
              assert { u_ >= round RTP (x.u * y.l) };
              assert { forall m. (round m (x.l * y.u)) < (- max_real) -> l_ = (- large_real) };
              assert { forall m. (round m (x.u * y.l)) > max_real -> u_ = large_real };
              (*assert { is_ninf x \/ is_pinf y -> l_ = (- large_real) };*)
              { l=l_; u=u_; p_nan=p_nan }
          end

      else if y.u <= 0. then begin
        (* [x] <= 0 and [x] != [0] and [y] <= 0 and [y] != [0] *)
        assert { x.l < 0. /\ x.u <= 0. /\ y.l < 0. /\ y.u <= 0. };
        assert { not is_pinf x /\ not is_pinf y };
        let l_ = r_dn (x.u * y.u) in
        let u_ = if is_ninf x || is_ninf y then large_real else r_up (x.l * y.l) in
        let p_nan = x.p_nan || y.p_nan || (x.u = 0. && is_ninf y) || (is_ninf x && y.u = 0.) in
          assert { l_ <= u_ };
          assert { forall m. l_ <= round m (x.u * y.u) };
          assert { forall m. u_ >= round m (x.l * y.l) };
          assert { l_ <= round RTN (x.u * y.u) };
          assert { u_ >= round RTP (x.l * y.l) };
          assert { forall m. (round m (x.u * y.u)) < (- max_real) -> l_ = (- large_real) };
          assert { forall m. (round m (x.l * y.l)) > max_real -> u_ = large_real };
          { l=l_; u=u_; p_nan=p_nan }
      end
      else
        (* [x] <= 0 and [x] != [0] and [y] strictly contains 0 *)
        let l_ = if is_ninf x || is_pinf y then - large_real else r_dn (x.l * y.u) in
        let u_ = if is_ninf x || is_ninf y then large_real else r_up (x.l * y.l) in
        let p_nan = x.p_nan || y.p_nan || is_ninf x || (x.u = 0. && (is_ninf y || is_pinf y)) in
          assert { l_ <= u_ };
          assert { forall m. l_ <= round m (x.l * y.u) };
          assert { forall m. u_ >= round m (x.l * y.l) };
          assert { l_ <= round RTN (x.l * y.u) };
          assert { u_ >= round RTP (x.l * y.l) };
          assert { forall m. (round m (x.l * y.u)) < (- max_real) -> l_ = (- large_real) };
          assert { forall m. (round m (x.l * y.l)) > max_real -> u_ = large_real };
          { l=l_; u=u_; p_nan=p_nan }
          (* TODO *)

    else 
      if y.l >= 0. then
        if y.u = 0. then
          (* [x] strictly contains 0 and [y] = [0] *)
          if not is_ninf x && not is_pinf x then
            if not x.p_nan && not y.p_nan then zeroI else zero_nan
          else 
            zero_nan
        else
          (* [x] strictly contains 0 and 0 <= [y] *)
          let l_ = if is_ninf x || is_pinf y then - large_real else r_dn (x.l * y.u) in
          let u_ = if is_pinf x || is_pinf y then large_real else r_up (x.u * y.u) in
          let p_nan = x.p_nan || y.p_nan || is_pinf y || ((is_ninf x || is_pinf x) && y.l = 0.) in
            assert { l_ <= u_ };
            assert { forall m. l_ <= round m (x.l * y.u) };
            assert { forall m. u_ >= round m (x.u * y.u) };
            assert { l_ <= round RTN (x.l * y.u) };
            assert { u_ >= round RTP (x.u * y.u) };
            assert { forall m. (round m (x.l * y.u)) < (- max_real) -> l_ = (- large_real) };
            assert { forall m. (round m (x.u * y.u)) > max_real -> u_ = large_real };
            (*assert { is_ninf x \/ is_pinf y -> l_ = (- large_real) };*)
            { l=l_; u=u_; p_nan=p_nan }

      else if y.u <= 0. then
        (* [x] strictly contains 0 and [y] <= 0 *)
        let l_ = if is_pinf x || is_ninf y then - large_real else r_dn (x.u * y.l) in
        let u_ = if is_ninf x || is_ninf y then large_real else r_up (x.l * y.l) in
        let p_nan = x.p_nan || y.p_nan || is_ninf y || ((is_ninf x || is_pinf x) && y.u = 0.) in
          assert { l_ <= u_ };
          assert { forall m. l_ <= round m (x.u * y.l) };
          assert { forall m. u_ >= round m (x.l * y.l) };
          (*assert { l_ <= round RNE (x.u * y.l) };
          assert { u_ >= round RNE (x.l * y.l) };*)
          assert { forall m. (round m (x.u * y.l)) < (- max_real) -> l_ = (- large_real) };
          assert { forall m. (round m (x.l * y.l)) > max_real -> u_ = large_real };
          (*assert { is_pinf x \/ is_ninf y -> l_ = (- large_real) };*)
          { l=l_; u=u_; p_nan=p_nan }

      else begin
        (* [x] and [y] strictly contains 0 *)
        assert { x.l < 0. /\ 0. < x.u /\ y.l < 0. /\ 0. < y.u };
  
        let l1 = if is_ninf x || is_pinf y then - large_real else r_dn (x.l * y.u) in
        let l2 = if is_pinf x || is_ninf y then - large_real else r_dn (x.u * y.l) in
        let u1 = if is_ninf x || is_ninf y then large_real else r_up (x.l * y.l) in
        let u2 = if is_pinf x || is_pinf y then large_real else r_up (x.u * y.u) in
        if l1 < l2 then
          if u1 > u2 then begin
            assert { l1 <= u1 };
            assert { not is_pinf x /\ not is_ninf y /\ not is_pinf y };
            assert { forall m. l1 <= round m (x.l * y.u) };
            assert { forall m. u1 >= round m (x.l * y.l) };
            assert { forall m. round m (x.l * y.u) < (- max_real) -> l1 = - large_real };
            assert { forall m. round m (x.l * y.l) > max_real -> u1 = large_real };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              l1 <= round RTN (xx * yy) };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              u1 >= round RTP (xx * yy) };
            { l = l1; u = u1; p_nan = x.p_nan || y.p_nan || is_ninf x }
          end 
          else begin
            assert { l1 <= u2 };
            assert { not is_pinf x /\ not is_ninf y };
            (*assert { is_ninf x -> is_pinf y };*)
            assert { forall m. l1 <= round m (x.l * y.u) };
            assert { forall m. u2 >= round m (x.u * y.u) };
            assert { forall m. round m (x.l * y.u) < (- max_real) -> l1 = - large_real };
            assert { forall m. round m (x.u * y.u) > max_real -> u2 = large_real };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              l1 <= round RTN (xx * yy) };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              u2 >= round RTP (xx * yy) };
            { l = l1; u = u2; p_nan = x.p_nan || y.p_nan || is_ninf x || is_pinf y }
          end 
        else
          if u1 > u2 then begin
            assert { l2 <= u1 };
            assert { (*not is_ninf x /\*) not is_pinf x /\ not is_pinf y };
            assert { forall m. l2 <= round m (x.u * y.l) };
            assert { forall m. u1 >= round m (x.l * y.l) };
            assert { l2 <= round RTN (x.u * y.l) };
            assert { u1 >= round RTP (x.l * y.l) };
            assert { forall m. round m (x.u * y.l) < (- max_real) -> l2 = - large_real };
            assert { forall m. round m (x.l * y.l) > max_real -> u1 = large_real };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              l2 <= round RTN (xx * yy) };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              u1 >= round RTP (xx * yy) };
            { l = l2; u = u1; p_nan = x.p_nan || y.p_nan || is_ninf x || is_ninf y }
          end
          else begin
            assert { l1 >= l2 /\ u1 <= u2};
            assert { l2 <= u2 };
            assert { forall m. l2 <= round m (x.u * y.l) };
            assert { forall m. u2 >= round m (x.u * y.u) };
            assert { l2 <= round RTN (x.u * y.l) };
            assert { u2 >= round RTP (x.u * y.u) };
            assert { forall m. round m (x.u * y.l) < (- max_real) -> l2 = - large_real };
            (*assert { round RTN (x.u * y.l) < (- max_real) -> l2 = - large_real };*)
            assert { forall m. round m (x.u * y.u) > max_real -> u2 = large_real };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              l2 <= round RTN (xx * yy) };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              u2 >= round RTP (xx * yy) };
            { l = l2; u = u2; 
              p_nan = x.p_nan || y.p_nan || is_ninf x || is_pinf x || is_ninf y || is_pinf y }
          end

    end
end

module Division
  use real.Real
  use ieee_float.Float64
  use RealInterval
  use rineq.RdivLeCompat

  (* Auxiliary lemmas. *)

  lemma div_round_zero: 
    round RTN 0. = 0.

  lemma div_positive: forall x y.
    t'isFinite x -> t'real x >= 0. -> t'isFinite y -> t'real y > 0. -> 
      (*t'real x / t'real y >= 0. ->*)
      round RTN (t'real x / t'real y) >= (*round RTN 0*) 0.

  lemma div_negative: forall x y.
    t'isFinite x -> t'real x <= 0. -> t'isFinite y -> t'real y < 0. -> 
      (*t'real x / t'real y >= 0. ->*)
      round RTN (t'real x / t'real y) >= (*round RTN 0*) 0.

  lemma div_fin_ninf: forall xx yy.
    t'isFinite xx -> t'isFinite yy -> not is_zero yy -> is_minus_infinity (div RTN xx yy) ->
    round RTN (t'real xx / t'real yy) < (- max_real)

  lemma div_ninf_cond: forall xx yy.
    is_minus_infinity (div RTN xx yy) ->
    (is_minus_infinity xx /\ t'isFinite yy /\ t'real yy >= 0.) \/
    (is_plus_infinity xx  /\ t'isFinite yy /\ t'real yy <= 0.) \/
    ( t'isFinite xx /\ t'isFinite yy /\ not is_zero yy /\
      round RTN (t'real xx / t'real yy) < (- max_real) ) \/
    (t'isFinite xx /\ is_zero yy /\ not is_zero xx)

  lemma div_fin_pinf: forall xx yy.
    t'isFinite xx -> t'isFinite yy -> not is_zero yy -> is_plus_infinity (div RTN xx yy) ->
    round RTP (t'real xx / t'real yy) > max_real

  lemma div_pinf_cond: forall xx yy.
    is_plus_infinity (div RTP xx yy) ->
    (is_minus_infinity xx /\ t'isFinite yy /\ t'real yy <= 0.) \/
    (is_plus_infinity xx  /\ t'isFinite yy /\ t'real yy >= 0.) \/
    ( t'isFinite xx /\ t'isFinite yy /\ not is_zero yy /\
      round RTP (t'real xx / t'real yy) > max_real ) \/
    (t'isFinite xx /\ is_zero yy /\ not is_zero xx)

  lemma div_nan_cond: forall xx yy.
    is_nan (div RNE xx yy) ->
    (is_nan xx \/ is_nan yy) \/ 
    (is_infinite xx /\ is_infinite yy) \/
    (is_zero xx /\ is_zero yy)

  (* Operator definition. *)

  let op (x y : t) : t
    requires { ordered x /\ ordered y }
    requires { - large_real <= x.l /\ x.u <= large_real }
    requires { - large_real <= y.l /\ y.u <= large_real }

    ensures { ordered result }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      not is_zero yy -> no_overflow RTN (t'real xx / t'real yy) ->
      t'isFinite (div RTN xx yy) -> result.l <= t'real (div RTN xx yy) }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      not is_zero yy -> no_overflow RTP (t'real xx / t'real yy) ->
      t'isFinite (div RTP xx yy) -> t'real (div RTP xx yy) <= result.u }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      is_minus_infinity (div RTN xx yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_minus_infinity (div RTN xx yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      is_plus_infinity (div RTP xx yy) -> result.u = large_real }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_plus_infinity (div RTP xx yy) -> result.u = large_real } 

    ensures { forall xx. forall yy.
      (is_nan xx -> x.p_nan) -> (is_nan yy -> x.p_nan) -> 
      (is_zero xx -> x.l <= 0. /\ 0. <= x.u) ->
      (is_zero yy -> y.l <= 0. /\ 0. <= y.u) ->
      (is_plus_infinity xx -> is_pinf x) -> (is_minus_infinity xx -> is_ninf x) -> 
      (is_plus_infinity yy -> is_pinf y) -> (is_minus_infinity yy -> is_ninf y) ->
      is_nan (div RNE xx yy) -> result.p_nan }

    ensures { forall xx. forall yy. fp_in_ri xx x -> fp_in_ri yy y ->
      (is_zero xx -> x.l <= 0. /\ 0. <= x.u) ->
      (is_zero yy -> y.l <= 0. /\ 0. <= y.u) ->

      ( no_overflow RTN (t'real xx / t'real yy) ->
        t'isFinite (div RTN xx yy) -> result.l <= t'real (div RTN xx yy) ) /\ 
      ( no_overflow RTP (t'real xx / t'real yy) ->
        t'isFinite (div RTP xx yy) -> t'real (div RTP xx yy) <= result.u ) /\
      (is_minus_infinity (div RTN xx yy) -> result.l <= (- large_real)) /\
      (is_plus_infinity (div RTP xx yy) -> result.u >= large_real) /\
      (is_nan (div RNE xx yy) -> result.p_nan)
    }

  = if y.l > 0. then
      if x.l >= 0. then
        if not is_pinf y then
          (* 0 <= [x] and 0 < [y] < +inf *)
          let l_ = if is_ninf x then - large_real else r_dn (x.l / y.u) in
          let u_ = if is_pinf x then large_real else r_up (x.u / y.l) in
          { l = l_; u = u_; p_nan = x.p_nan || y.p_nan }
        else
          (* 0 <= [x] and 0 < [y] = +inf *)
          let l_ = if is_ninf x then - large_real else (*r_dn (x.l / y.u)*) 0. in
          let u_ = if is_pinf x then large_real else r_up (x.u / y.l) in
          assert { x.l >= 0. /\ y.l > 0. };
          assert { is_pinf y };
          assert { l_ <= round RTN (x.l / y.u) };
          assert { u_ >= round RTP (x.u / y.l) };
          (*assert { forall m. round m (x.l / y.u) < (- max_real) -> l_ = - large_real };*)
          assert { forall m. round m (x.u / y.l) > max_real -> u_ = large_real };
          { l = l_; u = u_; p_nan = x.p_nan || y.p_nan || is_pinf x }

      else if x.u <= 0. then
        if not is_pinf y then
          (* [x] <= 0 and 0 < [y] < +inf *)
          { l = r_dn (x.l / y.l); u = r_up (x.u / y.u); p_nan = x.p_nan || y.p_nan }
        else
          (* [x] <= 0 and 0 < [y] = +inf *)
          { l = r_dn (x.l / y.l); u = 0.; p_nan = x.p_nan || y.p_nan || is_ninf x }

      else begin
        assert { x.l < 0. /\ 0. < x.u /\ 0. < y.l };
        (* [x] strictly contains 0 and 0 < [y] *)
        let l_ = if is_ninf x then - large_real else r_dn (x.l / y.l) in
        let u_ = if is_pinf x then large_real else r_up (x.u / y.l) in
          assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                   l_ <= round RTN (xx / yy) };
          assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                   round RTN (xx / yy) < (- max_real) -> l_ = - large_real };
          assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                   u_ >= round RTP (xx / yy) };
          assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                   round RTP (xx / yy) > max_real -> u_ = large_real };

          { l = l_; u = u_; 
            p_nan = x.p_nan || y.p_nan || (is_inf x && is_pinf y) }
      end

    else if y.u < 0. then
      if x.l >= 0. then
        if not is_ninf y then
          (* 0 <= [x] and -inf < [y] < 0 *)
          { l = r_dn (x.u / y.u); u = r_up (x.l / y.l); p_nan = x.p_nan || y.p_nan }
        else 
          (* 0 <= [x] and -inf = [y] < 0 *)
          { l = r_dn (x.u / y.u); u = 0.; p_nan = x.p_nan || y.p_nan || is_pinf x }

      else if x.u <= 0. then
        if not is_ninf y then
          (* [x] <= 0 and -inf < [y] < 0 *)
          { l = r_dn (x.u / y.l); u = r_up (x.l / y.u); p_nan = x.p_nan || y.p_nan }
        else
          (* [x] <= 0 and -inf = [y] < 0 *)
          let u_ = if is_pinf x then large_real else r_up (x.l / y.u) in
          assert { u_ >= round RTP (x.l / y.u) };
          assert { forall m. round m (x.l / y.u) > max_real -> u_ = large_real };
          { l = 0.; u = u_; p_nan = x.p_nan || y.p_nan || is_ninf x }

      else begin
        assert { x.l < 0. /\ 0. < x.u /\ y.u < 0. };
        (* [x] strictly contains 0 and [y] < 0 *)
        let l_ = if is_pinf x then - large_real else r_dn (x.u / y.u) in
        let u_ = if is_ninf x then large_real else r_up (x.l / y.u) in
        assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                 l_ <= round RTN (xx / yy) };
        assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                 round RTN (xx / yy) < (- max_real) -> l_ = - large_real };
        assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                 u_ >= round RTP (xx / yy) };
        assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                 round RTP (xx / yy) > max_real -> u_ = large_real };

        { l = l_; u = u_; p_nan = x.p_nan || y.p_nan || (is_inf x && is_ninf y) }
      end

    else
      (* [y] contains 0; results in Entire *)
      { l = - large_real; u = large_real;
        p_nan = x.p_nan || y.p_nan || (is_inf x && is_inf y) || (x.l <= 0. && 0. <= x.u) }

end


module Comparison
  use real.Real
  use ieee_float.Float64
  use RealInterval

  (* Weak operators. *)

  predicate gt0_n (f:t)
  = is_pinf_s f \/ f.u > 0.

  predicate geq0_n (f:t)
  = is_pinf_s f \/ f.u >= 0.

  predicate lt0_n (f:t)
  = f.p_nan \/ is_ninf f \/ f.l < 0.

  predicate leq0_n (f:t)
  = f.p_nan \/ is_ninf f \/ f.l <= 0.

  (* Strong operators. *)

  predicate gt0_p (f:t)
  = not f.p_nan /\ not (is_ninf f) /\ f.l > 0.

  predicate geq0_p (f:t)
  = not f.p_nan /\ not (is_ninf f) /\ f.l >= 0.

  predicate lt0_p (f:t)
  = not (is_pinf f) /\ f.u < 0.

  predicate leq0_p (f:t)
  = not (is_pinf f) /\ f.u <= 0.

  (* Logical equivalence. *)

  lemma gt_leq: forall f. ordered f ->
    (gt0_n f <-> not leq0_p f)

  lemma geq_lt: forall f. ordered f ->
    (geq0_n f <-> not lt0_p f)

  lemma lt_geq: forall f. ordered f -> 
    (lt0_n f <-> not geq0_p f)

  lemma leq_gt: forall f. ordered f -> 
    (leq0_n f <-> not gt0_p f)

  (* Correctness. *)

  lemma gt0_n_complete: forall f. ordered f -> not gt0_n f ->
    forall ff. fp_in_ri ff f -> not (ff .> zeroF)

  lemma leq0_n_complete: forall f. ordered f -> not leq0_n f ->
    forall ff. fp_in_ri ff f -> (*not (not (ff .> zeroF))*) ff .> zeroF

  lemma geq0_p_sound: forall f. ordered f -> geq0_p f -> 
    forall ff. fp_in_ri ff f -> ff .>= zeroF

  lemma gt0_p_sound: forall f. ordered f -> gt0_p f -> 
    forall ff. fp_in_ri ff f -> ff .> zeroF

  lemma leq0_p_sound: forall f. ordered f -> leq0_p f -> 
    forall ff. fp_in_ri ff f -> not (ff .> zeroF)

end
