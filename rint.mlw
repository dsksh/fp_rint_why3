
module RealInterval
  use real.Real
  use real.Abs
  use ieee_float.Float64
  use export ieee_float.RoundingMode

  val constant max_real : real
    ensures { result = Float64.max_real }
  val constant large_real : real
    ensures { result > 2. * max_real }

  val constant err_denom : real
  val constant err_min : real

  type t = { l : real; u : real; p_nan : bool }

  (* Assume only "ordered" intervals. *)
  (*axiom order: forall t. t.l <= t.u*)

  predicate ordered (x:t) = x.l <= x.u

  let constant zeroI : t = { l=0.; u=0.; p_nan=false }
  let constant zero_nan : t = { l=0.; u=0.; p_nan=true }

  let predicate is_ninf_s_ (x:real) = x <= (- large_real)
  let predicate is_pinf_s_ (x:real) = x >= large_real
  let predicate is_inf_s_ (x:real) = is_ninf_s_ x || is_pinf_s_ x

  let predicate is_ninf_s (x:t) = is_ninf_s_ x.l
  let predicate is_pinf_s (x:t) = is_pinf_s_ x.u
  let predicate is_inf_s (x:t) = is_ninf_s x || is_pinf_s x

  let predicate is_ninf_ (x:real) = x < (- max_real)
  let predicate is_pinf_ (x:real) = x > max_real
  let predicate is_inf_ (x:real) = is_ninf_ x || is_pinf_ x

  let predicate is_ninf (x:t) = is_ninf_ x.l
  let predicate is_pinf (x:t) = is_pinf_ x.u
  let predicate is_inf (x:t) = is_ninf x || is_pinf x

  let predicate diff_sgn (x:real) (y:real) = (x >= 0. && y < 0.) || (x < 0. && y >= 0.)

  let function r_dn (v:real)
    ensures { result <= round RTN v }
    ensures { forall m. result <= round m v }
    ensures { forall m. ((round m v) < (- max_real) -> result = (- large_real)) }
  = let w = v - ((if v >= 0. then v else -v) / err_denom) - err_min in
    if w >= -max_real then w else -large_real

  let function r_up (v:real)
    ensures { result >= round RTP v }
    ensures { forall m. result >= round m v }
    ensures { forall m. ((round m v) > max_real -> result = large_real) }
  = let w = v + ((if v >= 0. then v else -v) / err_denom) + err_min in
    if w <= max_real then w else large_real

  predicate fp_in_ri (xx:Float64.t) (x:t)
  = (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) /\
    (is_minus_infinity xx -> x.l <= (- large_real)) /\
    (is_plus_infinity xx -> x.u >= large_real) /\
    (is_nan xx -> x.p_nan)

end

module Addition
  use real.Real
  use ieee_float.Float64
  use RealInterval

  (*lemma add_lb: forall xx yy.
    t'isFinite xx -> t'isFinite yy ->
    (*t'real yy = 0. -> t'real yy >= 0. ->*)
    t'real xx <= 1. -> t'real xx >= 0. ->
    t'real (add RTN xx yy) <= t'real (add RTP xx yy)
    *)

  (*lemma round_lb: forall x m.
    (*no_overflow (round RTN x) -> no_overflow (round RTP x) ->*)
    in_range x ->
    round RTN x <= round m x
  *)

  let op (x y : t) : t
    requires { ordered x /\ ordered y }
    ensures { ordered result }

    (*ensures { forall xx. forall yy. 
      (x.l <= t'real xx /\ t'real xx <= x.u) ->
      (y.l <= t'real yy /\ t'real yy <= y.u) ->
      result.l <= (t'real xx) + (t'real yy) /\ (t'real xx) + (t'real yy) <= result.u }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      no_overflow RNE (t'real xx + t'real yy) ->
      t'isFinite (xx .+ yy) -> 
      result.l <= t'real (xx .+ yy) /\ t'real (xx .+ yy) <= result.u }

    ensures { forall xx. forall yy. (*fp_in_ri xx x -> fp_in_ri yy y ->*)
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_minus_infinity (xx .+ yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy. (*fp_in_ri xx x -> fp_in_ri yy y ->*)
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_plus_infinity (xx .+ yy) -> result.u = large_real }

    ensures { forall xx. forall yy. (*fp_in_ri xx x -> fp_in_ri yy y ->*)
      (is_nan xx -> x.p_nan) -> (is_nan yy -> x.p_nan) -> 
      (is_plus_infinity xx -> is_pinf x) -> (is_minus_infinity xx -> is_ninf x) -> 
      (is_plus_infinity yy -> is_pinf y) -> (is_minus_infinity yy -> is_ninf y) ->
      is_nan (xx .+ yy) -> result.p_nan }
    *)

    ensures { forall xx yy. fp_in_ri xx x -> fp_in_ri yy y ->
      fp_in_ri (xx .+ yy) result }

    ensures { forall xx yy m. fp_in_ri xx x -> fp_in_ri yy y ->
      ( t'isFinite (add RTN xx yy) -> no_overflow RTN (t'real xx + t'real yy) ->
          result.l <= t'real (add RTN xx yy) ) /\ 
      (t'isFinite (add RTP xx yy) -> no_overflow RTP (t'real xx + t'real yy) ->
          result.u >= t'real (add RTP xx yy)) /\ 
      (is_minus_infinity (add m xx yy) -> result.l <= (- large_real)) /\
      (is_plus_infinity (add m xx yy) -> result.u >= large_real) /\
      (is_nan (add m xx yy) -> result.p_nan) }

    (* Note that some NaN cases are treated inaccurately. 
       E.g. [-inf,x] + [inf,inf] becomes {l=0.; u=inf; p_nan=true}), 
            which should be interval {NaN}, but we leave it as is. *)

  = let l_ = r_dn (x.l + y.l) in
    let u_ = r_up (x.u + y.u) in
    let p_nan = x.p_nan || y.p_nan || 
      (is_ninf x && is_pinf y) || (is_pinf x && is_ninf y) in
    assert { l_ <= u_ };
    (*assert { forall m. l_ <= round m (x.l + y.l) };
    assert { forall m. u_ >= round m (x.u + y.u) };*)
    (*assert { l_ <= round RTN (x.l + y.l) };
    assert { u_ >= round RTP (x.u + y.u) };*)
    assert { l_ <= round RNE (x.l + y.l) };
    assert { u_ >= round RNE (x.u + y.u) };
    assert { forall m. (round m (x.l + y.l)) < (- max_real) -> l_ = (- large_real) };
    assert { forall m. (round m (x.u + y.u)) > max_real -> u_ = large_real };
    (*assert { round RTN (x.l + y.l) < (- max_real) -> l_ = (- large_real) };
    assert { round RTP (x.u + y.u) > max_real -> u_ = large_real };*)

    (*assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> l_ <= round RTN (xx + yy) };
    assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> u_ >= round RTP (xx + yy) };*)

    { l = l_; u = u_; p_nan = p_nan }

end

module Subtraction
  use real.Real
  use ieee_float.Float64
  use RealInterval

  let op (x y : t)
    requires { ordered x /\ ordered y }
    ensures { ordered result }

    (*ensures { forall xx. forall yy. 
      (x.l <= t'real xx /\ t'real xx <= x.u) ->
      (y.l <= t'real yy /\ t'real yy <= y.u) ->
      result.l <= (t'real xx) - (t'real yy) /\ (t'real xx) - (t'real yy) <= result.u }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      no_overflow RNE (t'real xx - t'real yy) ->
      t'isFinite (xx .- yy) -> 
      result.l <= t'real (xx .- yy) /\ t'real (xx .- yy) <= result.u }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_minus_infinity (xx .- yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_plus_infinity (xx .- yy) -> result.u = large_real } 

    ensures { forall xx. forall yy.
      (is_nan xx -> x.p_nan) -> (is_nan yy -> x.p_nan) -> 
      (is_plus_infinity xx -> is_pinf x) -> (is_minus_infinity xx -> is_ninf x) -> 
      (is_plus_infinity yy -> is_pinf y) -> (is_minus_infinity yy -> is_ninf y) ->
      is_nan (xx .- yy) -> result.p_nan }
    *)

    ensures { forall xx. forall yy. fp_in_ri xx x -> fp_in_ri yy y ->
      fp_in_ri (xx .- yy) result
    }

    ensures { forall xx yy m. fp_in_ri xx x -> fp_in_ri yy y ->
      ( t'isFinite (add RTN xx yy) -> no_overflow RTN (t'real xx - t'real yy) ->
          result.l <= t'real (sub RTN xx yy) ) /\ 
      (t'isFinite (add RTP xx yy) -> no_overflow RTP (t'real xx - t'real yy) ->
          result.u >= t'real (sub RTP xx yy)) /\ 
      (is_minus_infinity (sub m xx yy) -> result.l <= (- large_real)) /\
      (is_plus_infinity (sub m xx yy) -> result.u >= large_real) /\
      (is_nan (sub m xx yy) -> result.p_nan) }

    (* Note that some NaN cases are treated inaccurately. 
       E.g. [-inf,x] - [inf,inf] becomes {l=0.; u=-inf; p_nan=true}), 
            which should be interval {NaN}, but we leave it as is. *)

  = let l_ = r_dn (x.l - y.u) in
    let u = r_up (x.u - y.l) in
    let p_nan = x.p_nan || y.p_nan || 
      (is_ninf x && is_ninf y) || (is_pinf x && is_pinf y) in
    assert { l_ <= u };
    assert { l_ <= round RNE (x.l - y.u) };
    assert { u >= round RNE (x.u - y.l) };
    assert { forall m. (round m (x.l - y.u)) < (- max_real) -> l_ = (- large_real) };
    assert { forall m. (round m (x.u - y.l)) > max_real -> u = large_real };
    { l = l_; u = u; p_nan = p_nan }


  let function sub_exact (x y : t) : t
    requires { ordered x /\ ordered y }
    ensures { ordered result }

    ensures { forall xx yy. 
      x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
      (result.l <= xx - yy /\ xx - yy <= result.u) /\
      (*(is_ninf_ (xx - yy) -> result.l <= - large_real) /\
      (is_pinf_ (xx - yy) -> result.u >= large_real) /\*)
      ((x.p_nan \/ y.p_nan) -> result.p_nan) /\
      ((is_ninf_ xx /\ is_ninf_ yy) -> result.p_nan) /\
      ((is_pinf_ xx /\ is_pinf_ yy) -> result.p_nan) 
    }

    (*ensures { forall xx. forall yy. fp_in_ri xx x -> fp_in_ri yy y ->
      (*(t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) /\*)
      (result.l <= t'real xx - t'real yy <= result.u) /\
      ((is_minus_infinity xx \/ is_plus_infinity yy) -> result.l <= (- large_real)) /\
      ((is_plus_infinity xx \/ is_minus_infinity yy) -> result.u >= large_real) /\
      ((is_nan xx \/ is_nan yy) -> result.p_nan) /\
      ((is_minus_infinity xx \/ is_minus_infinity yy) -> result.p_nan) /\
      ((is_plus_infinity xx \/ is_plus_infinity yy) -> result.p_nan) 
    }
    *)

  = let l_ = x.l - y.u in
    let u = x.u - y.l in
    let p_nan = x.p_nan || y.p_nan || 
      (is_ninf x && is_ninf y) || (is_pinf x && is_pinf y) in
    (*assert { l_ <= u };
    assert { l_ <= round RNE (x.l - y.u) };
    assert { u >= round RNE (x.u - y.l) };
    assert { forall m. (round m (x.l - y.u)) < (- max_real) -> l_ = (- large_real) };
    assert { forall m. (round m (x.u - y.l)) > max_real -> u = large_real };*)
    { l = l_; u = u; p_nan = p_nan }

end

module Multiplication
  use real.Real
  use ieee_float.Float64
  use RealInterval
  use rineq.RmultLeCompat

  (* Auxiliary lemmas. *)

  lemma mult_fin_ninf: forall xx yy.
    t'isFinite xx -> t'isFinite yy -> is_minus_infinity (mul RTN xx yy) ->
    round RTN (t'real xx * t'real yy) < (- max_real)

  lemma mult_ninf_conds: forall xx yy.
    is_minus_infinity (mul RTN xx yy) ->
    ( t'isFinite xx /\ t'isFinite yy /\
      round RTN (t'real xx * t'real yy) < (- max_real) ) \/
    (t'isFinite xx /\ t'real xx > 0. /\ is_minus_infinity yy) \/
    (t'isFinite xx /\ t'real xx < 0. /\ is_plus_infinity yy) \/
    (is_minus_infinity xx /\ t'isFinite yy /\ t'real yy > 0.) \/
    (is_plus_infinity xx  /\ t'isFinite yy /\ t'real yy < 0.) \/
    (is_minus_infinity xx /\ is_plus_infinity yy) \/
    (is_plus_infinity xx  /\ is_minus_infinity yy)

  lemma mult_fin_pinf: forall xx yy.
    t'isFinite xx -> t'isFinite yy -> is_plus_infinity (mul RTP xx yy) ->
    round RTP (t'real xx * t'real yy) > max_real

  lemma mult_pinf_conds: forall xx yy.
    is_plus_infinity (mul RTP xx yy) ->
    ( t'isFinite xx /\ t'isFinite yy /\
      round RTP (t'real xx * t'real yy) > max_real ) \/
    (t'isFinite xx /\ t'real xx < 0. /\ is_minus_infinity yy ) \/
    (t'isFinite xx /\ t'real xx > 0. /\ is_plus_infinity yy) \/
    (is_minus_infinity xx /\ t'isFinite yy /\ t'real yy < 0.) \/
    (is_plus_infinity xx  /\ t'isFinite yy /\ t'real yy > 0.) \/
    (is_minus_infinity xx /\ is_minus_infinity yy) \/
    (is_plus_infinity xx  /\ is_plus_infinity yy)

  lemma mult_nan_conds: forall xx yy. forall m.
    is_nan (mul m xx yy) ->
    (is_nan xx \/ is_nan yy) \/
    (is_zero xx /\ is_infinite yy) \/
    (is_infinite xx /\ is_zero yy)

  (*lemma mult_bnd: forall x y. in_range x -> in_range y ->
    - large_real < x * y /\ x * y < large_real*)

  (* Operator definition. *)

  let op (x y : t) : t
    requires { ordered x /\ ordered y }
    requires { - large_real <= x.l /\ x.u <= large_real }
    requires { - large_real <= y.l /\ y.u <= large_real }

    ensures { ordered result }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      no_overflow RTN (t'real xx * t'real yy) ->
      t'isFinite (mul RTN xx yy) -> result.l <= t'real (mul RTN xx yy) }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      no_overflow RTP (t'real xx * t'real yy) ->
      t'isFinite (mul RTP xx yy) -> t'real (mul RTP xx yy) <= result.u }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      (*round RTN (t'real xx * t'real yy) < (- max_real) -> result.l = (- large_real)*)
      is_minus_infinity (mul RTN xx yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_minus_infinity (mul RTN xx yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      is_plus_infinity (mul RTP xx yy) -> result.u = large_real }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_plus_infinity (mul RTP xx yy) -> result.u = large_real } 

    ensures { forall xx. forall yy.
      (is_nan xx -> x.p_nan) -> (is_nan yy -> x.p_nan) -> 
      (is_zero xx -> x.l <= 0. /\ 0. <= x.u) ->
      (is_zero yy -> y.l <= 0. /\ 0. <= y.u) ->
      (is_plus_infinity xx -> is_pinf x) -> (is_minus_infinity xx -> is_ninf x) -> 
      (is_plus_infinity yy -> is_pinf y) -> (is_minus_infinity yy -> is_ninf y) ->
      is_nan (mul RNE xx yy) -> result.p_nan }

    ensures { forall xx. forall yy. fp_in_ri xx x -> fp_in_ri yy y ->
      (is_zero xx -> x.l <= 0. /\ 0. <= x.u) ->
      (is_zero yy -> y.l <= 0. /\ 0. <= y.u) ->

      (*fp_in_ri (xx .* yy) result*)

      ( no_overflow RTN (t'real xx * t'real yy) ->
        t'isFinite (mul RTN xx yy) -> result.l <= t'real (mul RTN xx yy) ) /\ 
      ( no_overflow RTP (t'real xx * t'real yy) ->
        t'isFinite (mul RTP xx yy) -> t'real (mul RTP xx yy) <= result.u ) /\
      (is_minus_infinity (mul RTN xx yy) -> result.l <= (- large_real)) /\
      (is_plus_infinity (mul RTP xx yy) -> result.u >= large_real) /\
      (is_nan (mul RNE xx yy) -> result.p_nan)
    }

  = if x.l >= 0. then
      if x.u = 0. then
        if not is_ninf y && not is_pinf y then
          (* [x] = [0] *)
          if not x.p_nan && not y.p_nan then zeroI else zero_nan
        else
          (* [x] = [0] and (-inf = [y] or [y] = +inf) *)
          zero_nan

      else 
        if y.l >= 0. then
          if y.u = 0. then
            (* 0 <= [x] and [x] != [0] and [y] = [0] *)
            if not is_pinf x && not x.p_nan && not y.p_nan then
              zeroI 
            else 
              zero_nan
          else begin
            (* 0 <= [x] and [x] != [0] and 0 <= [y] and [y] != [0] *)
            assert { 0. <= x.l /\ 0. < x.u /\ 0. <= y.l /\ 0. < y.u };
            assert { not is_ninf x /\ not is_ninf y };
            let l_ = r_dn (x.l * y.l) in
            let u_ = if is_pinf x || is_pinf y then large_real else r_up (x.u * y.u) in
            let p_nan = x.p_nan || y.p_nan || (x.l = 0. && is_pinf y) || (is_pinf x && y.l = 0.) in
              (*assert { x.l*y.l <= x.u*y.u };*)
              assert { l_ <= u_ };
              assert { forall m. l_ <= round m (x.l * y.l) };
              assert { forall m. u_ >= round m (x.u * y.u) };
              assert { l_ <= round RTN (x.l * y.l) };
              assert { u_ >= round RTP (x.u * y.u) };
              assert { forall m. (round m (x.l * y.l)) < (- max_real) -> l_ = (- large_real) };
              assert { forall m. (round m (x.u * y.u)) > max_real -> u_ = large_real };
              assert { round RTN (x.l * y.l) < (- max_real) -> l_ = (- large_real) };
              assert { round RTP (x.u * y.u) > max_real -> u_ = large_real };
              (*assert { x.l * y.l >= 0. };*)
              { l=l_; u=u_; p_nan=p_nan }
          end

        else if y.u <= 0. then begin
          (* 0 <= [x] and [x] != [0] and [y] <= 0 and [y] != [0] *)
          assert { 0. <= x.l /\ 0. < x.u /\ y.u <= 0. /\ y.l < 0. };
          let l_ = if is_pinf x || is_ninf y then - large_real else r_dn (x.u * y.l) in
          let u_ = r_up (x.l * y.u) in
          let p_nan = x.p_nan || y.p_nan || (x.l = 0. && is_ninf y) || (is_pinf x && y.u = 0.) in
            assert { l_ <= u_ };
            assert { forall m. l_ <= round m (x.u * y.l) };
            assert { forall m. u_ >= round m (x.l * y.u) };
            assert { l_ <= round RTN (x.u * y.l) };
            assert { u_ >= round RTP (x.l * y.u) };
            assert { forall m. (round m (x.u * y.l)) < (- max_real) -> l_ = (- large_real) };
            assert { forall m. (round m (x.l * y.u)) > max_real -> u_ = large_real };
            { l=l_; u=u_; p_nan=p_nan }
            (* TODO *)
        end
        else begin
          (* 0 <= [x] and [x] != [0] and [y] strictly contains 0 *)
          assert { 0. <= x.l /\ 0. < x.u /\ y.l < 0. /\ 0. < y.u };
          let l_ = if is_pinf x || is_ninf y then - large_real else r_dn (x.u * y.l) in
          let u_ = if is_pinf x || is_pinf y then large_real else r_up (x.u * y.u) in
          let p_nan = x.p_nan || y.p_nan || is_pinf x || (x.l = 0. && (is_ninf y || is_pinf y)) in
            assert { l_ <= u_ };
            assert { forall m. l_ <= round m (x.u * y.l) };
            assert { forall m. u_ >= round m (x.u * y.u) };
            assert { l_ <= round RTN (x.u * y.l) };
            assert { u_ >= round RTP (x.u * y.u) };
            assert { forall m. (round m (x.u * y.l)) < (- max_real) -> l_ = (- large_real) };
            assert { forall m. (round m (x.u * y.u)) > max_real -> u_ = large_real };
            { l=l_; u=u_; p_nan=p_nan }
        end
    else 
      if x.u <= 0. then
        if y.l >= 0. then
          if not is_pinf y && y.u = 0. then
            (* [x] <= 0 and [x] != [0] and [y] = [0] *)
            if not is_ninf x && not x.p_nan && not y.p_nan then
              zeroI 
            else
              zero_nan
          else begin
            (* [x] <= 0 and [x] != [0] and 0 <= [y] and [y] != [0] *)
            assert { x.l < 0. /\ x.u <= 0. /\ 0. <= y.l /\ 0. < y.u };
            assert { not is_pinf x /\ not is_ninf y };
            let l_ = if is_ninf x || is_pinf y then -large_real else r_dn (x.l * y.u) in
            let u_ = r_up (x.u * y.l) in
            let p_nan = x.p_nan || y.p_nan || (x.u = 0. && is_pinf y) || (is_ninf x && y.l = 0.) in
              assert { l_ <= u_ };
              assert { forall m. l_ <= round m (x.l * y.u) };
              assert { forall m. u_ >= round m (x.u * y.l) };
              assert { l_ <= round RTN (x.l * y.u) };
              assert { u_ >= round RTP (x.u * y.l) };
              assert { forall m. (round m (x.l * y.u)) < (- max_real) -> l_ = (- large_real) };
              assert { forall m. (round m (x.u * y.l)) > max_real -> u_ = large_real };
              (*assert { is_ninf x \/ is_pinf y -> l_ = (- large_real) };*)
              { l=l_; u=u_; p_nan=p_nan }
          end

      else if y.u <= 0. then begin
        (* [x] <= 0 and [x] != [0] and [y] <= 0 and [y] != [0] *)
        assert { x.l < 0. /\ x.u <= 0. /\ y.l < 0. /\ y.u <= 0. };
        assert { not is_pinf x /\ not is_pinf y };
        let l_ = r_dn (x.u * y.u) in
        let u_ = if is_ninf x || is_ninf y then large_real else r_up (x.l * y.l) in
        let p_nan = x.p_nan || y.p_nan || (x.u = 0. && is_ninf y) || (is_ninf x && y.u = 0.) in
          assert { l_ <= u_ };
          assert { forall m. l_ <= round m (x.u * y.u) };
          assert { forall m. u_ >= round m (x.l * y.l) };
          assert { l_ <= round RTN (x.u * y.u) };
          assert { u_ >= round RTP (x.l * y.l) };
          assert { forall m. (round m (x.u * y.u)) < (- max_real) -> l_ = (- large_real) };
          assert { forall m. (round m (x.l * y.l)) > max_real -> u_ = large_real };
          { l=l_; u=u_; p_nan=p_nan }
      end
      else
        (* [x] <= 0 and [x] != [0] and [y] strictly contains 0 *)
        let l_ = if is_ninf x || is_pinf y then - large_real else r_dn (x.l * y.u) in
        let u_ = if is_ninf x || is_ninf y then large_real else r_up (x.l * y.l) in
        let p_nan = x.p_nan || y.p_nan || is_ninf x || (x.u = 0. && (is_ninf y || is_pinf y)) in
          assert { l_ <= u_ };
          assert { forall m. l_ <= round m (x.l * y.u) };
          assert { forall m. u_ >= round m (x.l * y.l) };
          assert { l_ <= round RTN (x.l * y.u) };
          assert { u_ >= round RTP (x.l * y.l) };
          assert { forall m. (round m (x.l * y.u)) < (- max_real) -> l_ = (- large_real) };
          assert { forall m. (round m (x.l * y.l)) > max_real -> u_ = large_real };
          { l=l_; u=u_; p_nan=p_nan }
          (* TODO *)

    else 
      if y.l >= 0. then
        if y.u = 0. then
          (* [x] strictly contains 0 and [y] = [0] *)
          if not is_ninf x && not is_pinf x && not x.p_nan && not y.p_nan then
            zeroI 
          else 
            zero_nan
        else
          (* [x] strictly contains 0 and 0 <= [y] *)
          let l_ = if is_ninf x || is_pinf y then - large_real else r_dn (x.l * y.u) in
          let u_ = if is_pinf x || is_pinf y then large_real else r_up (x.u * y.u) in
          let p_nan = x.p_nan || y.p_nan || is_pinf y || ((is_ninf x || is_pinf x) && y.l = 0.) in
            assert { l_ <= u_ };
            assert { forall m. l_ <= round m (x.l * y.u) };
            assert { forall m. u_ >= round m (x.u * y.u) };
            assert { l_ <= round RTN (x.l * y.u) };
            assert { u_ >= round RTP (x.u * y.u) };
            assert { forall m. (round m (x.l * y.u)) < (- max_real) -> l_ = (- large_real) };
            assert { forall m. (round m (x.u * y.u)) > max_real -> u_ = large_real };
            (*assert { is_ninf x \/ is_pinf y -> l_ = (- large_real) };*)
            { l=l_; u=u_; p_nan=p_nan }

      else if y.u <= 0. then
        (* [x] strictly contains 0 and [y] <= 0 *)
        let l_ = if is_pinf x || is_ninf y then - large_real else r_dn (x.u * y.l) in
        let u_ = if is_ninf x || is_ninf y then large_real else r_up (x.l * y.l) in
        let p_nan = x.p_nan || y.p_nan || is_ninf y || ((is_ninf x || is_pinf x) && y.u = 0.) in
          assert { l_ <= u_ };
          assert { forall m. l_ <= round m (x.u * y.l) };
          assert { forall m. u_ >= round m (x.l * y.l) };
          (*assert { l_ <= round RNE (x.u * y.l) };
          assert { u_ >= round RNE (x.l * y.l) };*)
          assert { forall m. (round m (x.u * y.l)) < (- max_real) -> l_ = (- large_real) };
          assert { forall m. (round m (x.l * y.l)) > max_real -> u_ = large_real };
          (*assert { is_pinf x \/ is_ninf y -> l_ = (- large_real) };*)
          { l=l_; u=u_; p_nan=p_nan }

      else begin
        (* [x] and [y] strictly contains 0 *)
        assert { x.l < 0. /\ 0. < x.u /\ y.l < 0. /\ 0. < y.u };
  
        let l1 = if is_ninf x || is_pinf y then - large_real else r_dn (x.l * y.u) in
        let l2 = if is_pinf x || is_ninf y then - large_real else r_dn (x.u * y.l) in
        let u1 = if is_ninf x || is_ninf y then large_real else r_up (x.l * y.l) in
        let u2 = if is_pinf x || is_pinf y then large_real else r_up (x.u * y.u) in
        if l1 < l2 then
          if u1 > u2 then begin
            assert { l1 <= u1 };
            assert { not is_pinf x /\ not is_ninf y /\ not is_pinf y };
            assert { forall m. l1 <= round m (x.l * y.u) };
            assert { forall m. u1 >= round m (x.l * y.l) };
            assert { forall m. round m (x.l * y.u) < (- max_real) -> l1 = - large_real };
            assert { forall m. round m (x.l * y.l) > max_real -> u1 = large_real };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              l1 <= round RTN (xx * yy) };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              u1 >= round RTP (xx * yy) };
            { l = l1; u = u1; p_nan = x.p_nan || y.p_nan || is_ninf x }
          end 
          else begin
            assert { l1 <= u2 };
            assert { not is_pinf x /\ not is_ninf y };
            (*assert { is_ninf x -> is_pinf y };*)
            assert { forall m. l1 <= round m (x.l * y.u) };
            assert { forall m. u2 >= round m (x.u * y.u) };
            assert { forall m. round m (x.l * y.u) < (- max_real) -> l1 = - large_real };
            assert { forall m. round m (x.u * y.u) > max_real -> u2 = large_real };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              l1 <= round RTN (xx * yy) };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              u2 >= round RTP (xx * yy) };
            { l = l1; u = u2; p_nan = x.p_nan || y.p_nan || is_ninf x || is_pinf y }
          end 
        else
          if u1 > u2 then begin
            assert { l2 <= u1 };
            assert { (*not is_ninf x /\*) not is_pinf x /\ not is_pinf y };
            assert { forall m. l2 <= round m (x.u * y.l) };
            assert { forall m. u1 >= round m (x.l * y.l) };
            assert { l2 <= round RTN (x.u * y.l) };
            assert { u1 >= round RTP (x.l * y.l) };
            assert { forall m. round m (x.u * y.l) < (- max_real) -> l2 = - large_real };
            assert { forall m. round m (x.l * y.l) > max_real -> u1 = large_real };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              l2 <= round RTN (xx * yy) };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              u1 >= round RTP (xx * yy) };
            { l = l2; u = u1; p_nan = x.p_nan || y.p_nan || is_ninf x || is_ninf y }
          end
          else begin
            assert { l1 >= l2 /\ u1 <= u2};
            assert { l2 <= u2 };
            assert { forall m. l2 <= round m (x.u * y.l) };
            assert { forall m. u2 >= round m (x.u * y.u) };
            assert { l2 <= round RTN (x.u * y.l) };
            assert { u2 >= round RTP (x.u * y.u) };
            assert { forall m. round m (x.u * y.l) < (- max_real) -> l2 = - large_real };
            (*assert { round RTN (x.u * y.l) < (- max_real) -> l2 = - large_real };*)
            assert { forall m. round m (x.u * y.u) > max_real -> u2 = large_real };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              l2 <= round RTN (xx * yy) };
            assert { forall xx yy. in_range xx -> in_range yy ->
              x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u -> 
              u2 >= round RTP (xx * yy) };
            { l = l2; u = u2; 
              p_nan = x.p_nan || y.p_nan || is_ninf x || is_pinf x || is_ninf y || is_pinf y }
          end

    end
end

module Division
  use real.Real
  use ieee_float.Float64
  use RealInterval
  use rineq.RdivLeCompat

  (* Auxiliary lemmas. *)

  lemma div_round_zero: 
    round RTN 0. = 0.

  lemma div_positive: forall x y.
    t'isFinite x -> t'real x >= 0. -> t'isFinite y -> t'real y > 0. -> 
      (*t'real x / t'real y >= 0. ->*)
      round RTN (t'real x / t'real y) >= (*round RTN 0*) 0.

  lemma div_negative: forall x y.
    t'isFinite x -> t'real x <= 0. -> t'isFinite y -> t'real y < 0. -> 
      (*t'real x / t'real y >= 0. ->*)
      round RTN (t'real x / t'real y) >= (*round RTN 0*) 0.

  lemma div_fin_ninf: forall xx yy.
    t'isFinite xx -> t'isFinite yy -> not is_zero yy -> is_minus_infinity (div RTN xx yy) ->
    round RTN (t'real xx / t'real yy) < (- max_real)

  lemma div_ninf_cond: forall xx yy.
    is_minus_infinity (div RTN xx yy) ->
    (is_minus_infinity xx /\ t'isFinite yy /\ t'real yy >= 0.) \/
    (is_plus_infinity xx  /\ t'isFinite yy /\ t'real yy <= 0.) \/
    ( t'isFinite xx /\ t'isFinite yy /\ not is_zero yy /\
      round RTN (t'real xx / t'real yy) < (- max_real) ) \/
    (t'isFinite xx /\ is_zero yy /\ not is_zero xx)

  lemma div_fin_pinf: forall xx yy.
    t'isFinite xx -> t'isFinite yy -> not is_zero yy -> is_plus_infinity (div RTN xx yy) ->
    round RTP (t'real xx / t'real yy) > max_real

  lemma div_pinf_cond: forall xx yy.
    is_plus_infinity (div RTP xx yy) ->
    (is_minus_infinity xx /\ t'isFinite yy /\ t'real yy <= 0.) \/
    (is_plus_infinity xx  /\ t'isFinite yy /\ t'real yy >= 0.) \/
    ( t'isFinite xx /\ t'isFinite yy /\ not is_zero yy /\
      round RTP (t'real xx / t'real yy) > max_real ) \/
    (t'isFinite xx /\ is_zero yy /\ not is_zero xx)

  lemma div_nan_cond: forall xx yy.
    is_nan (div RNE xx yy) ->
    (is_nan xx \/ is_nan yy) \/ 
    (is_infinite xx /\ is_infinite yy) \/
    (is_zero xx /\ is_zero yy)

  (* Operator definition. *)

  let op (x y : t) : t
    requires { ordered x /\ ordered y }
    requires { - large_real <= x.l /\ x.u <= large_real }
    requires { - large_real <= y.l /\ y.u <= large_real }

    ensures { ordered result }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      not is_zero yy -> no_overflow RTN (t'real xx / t'real yy) ->
      t'isFinite (div RTN xx yy) -> result.l <= t'real (div RTN xx yy) }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      not is_zero yy -> no_overflow RTP (t'real xx / t'real yy) ->
      t'isFinite (div RTP xx yy) -> t'real (div RTP xx yy) <= result.u }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      is_minus_infinity (div RTN xx yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_minus_infinity (div RTN xx yy) -> result.l = (- large_real) }

    ensures { forall xx. forall yy.
      (t'isFinite xx /\ x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy /\ y.l <= t'real yy /\ t'real yy <= y.u) ->
      is_plus_infinity (div RTP xx yy) -> result.u = large_real }

    ensures { forall xx. forall yy.
      (t'isFinite xx -> x.l <= t'real xx /\ t'real xx <= x.u) ->
      (t'isFinite yy -> y.l <= t'real yy /\ t'real yy <= y.u) ->
      (is_plus_infinity xx -> is_pinf_s x) -> (is_minus_infinity xx -> is_ninf_s x) -> 
      (is_plus_infinity yy -> is_pinf_s y) -> (is_minus_infinity yy -> is_ninf_s y) ->
      is_plus_infinity (div RTP xx yy) -> result.u = large_real } 

    ensures { forall xx. forall yy.
      (is_nan xx -> x.p_nan) -> (is_nan yy -> x.p_nan) -> 
      (is_zero xx -> x.l <= 0. /\ 0. <= x.u) ->
      (is_zero yy -> y.l <= 0. /\ 0. <= y.u) ->
      (is_plus_infinity xx -> is_pinf x) -> (is_minus_infinity xx -> is_ninf x) -> 
      (is_plus_infinity yy -> is_pinf y) -> (is_minus_infinity yy -> is_ninf y) ->
      is_nan (div RNE xx yy) -> result.p_nan }

    ensures { forall xx. forall yy. fp_in_ri xx x -> fp_in_ri yy y ->
      (is_zero xx -> x.l <= 0. /\ 0. <= x.u) ->
      (is_zero yy -> y.l <= 0. /\ 0. <= y.u) ->

      ( no_overflow RTN (t'real xx / t'real yy) ->
        t'isFinite (div RTN xx yy) -> result.l <= t'real (div RTN xx yy) ) /\ 
      ( no_overflow RTP (t'real xx / t'real yy) ->
        t'isFinite (div RTP xx yy) -> t'real (div RTP xx yy) <= result.u ) /\
      (is_minus_infinity (div RTN xx yy) -> result.l <= (- large_real)) /\
      (is_plus_infinity (div RTP xx yy) -> result.u >= large_real) /\
      (is_nan (div RNE xx yy) -> result.p_nan)
    }

  = if y.l > 0. then
      if x.l >= 0. then
        (* 0 <= [x] and 0 < [y] < +inf *)
        let l_ = if is_pinf y then 0. else r_dn (x.l / y.u) in
        let u_ = if is_pinf x then large_real else r_up (x.u / y.l) in
        assert { x.l >= 0. /\ y.l > 0. };
        assert { l_ <= round RTN (x.l / y.u) };
        assert { u_ >= round RTP (x.u / y.l) };
        (*assert { forall m. round m (x.l / y.u) < (- max_real) -> l_ = - large_real };*)
        assert { forall m. round m (x.u / y.l) > max_real -> u_ = large_real };
        { l = l_; u = u_; p_nan = x.p_nan || y.p_nan || (is_pinf x && is_pinf y) }

      else if x.u <= 0. then
        (* [x] <= 0 and 0 < [y] *)
        let l_ = if is_ninf x then - large_real else r_dn (x.l / y.l) in
        let u_ = if is_pinf y then 0. else r_up (x.u / y.u) in
        { l = l_; u = u_; p_nan = x.p_nan || y.p_nan || (is_ninf x && is_pinf y) }

      else begin
        (* [x] strictly contains 0 and 0 < [y] *)
        assert { x.l < 0. /\ 0. < x.u /\ 0. < y.l };
        let l_ = if is_ninf x then - large_real else r_dn (x.l / y.l) in
        let u_ = if is_pinf x then large_real else r_up (x.u / y.l) in
          assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                   l_ <= round RTN (xx / yy) };
          assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                   round RTN (xx / yy) < (- max_real) -> l_ = - large_real };
          assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                   u_ >= round RTP (xx / yy) };
          assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                   round RTP (xx / yy) > max_real -> u_ = large_real };

          { l = l_; u = u_; 
            p_nan = x.p_nan || y.p_nan || (is_inf x && is_pinf y) }
      end

    else if y.u < 0. then
      if x.l >= 0. then
        (* 0 <= [x] and -inf < [y] < 0 *)
        let l_ = if is_pinf x then - large_real else r_dn (x.u / y.u) in
        let u_ = if is_ninf y then 0. else r_up (x.l / y.l) in
        { l = l_; u = u_; p_nan = x.p_nan || y.p_nan || (is_pinf x && is_ninf y) }

      else if x.u <= 0. then
        (* [x] <= 0 and -inf < [y] < 0 *)
        let l_ = if is_ninf y then 0. else r_dn (x.u / y.l) in
        let u_ = if is_ninf x then large_real else r_up (x.l / y.u) in
          assert { u_ >= round RTP (x.l / y.u) };
          assert { forall m. round m (x.l / y.u) > max_real -> u_ = large_real };
          { l = l_; u = u_; p_nan = x.p_nan || y.p_nan || (is_ninf x && is_ninf y) }

      else begin
        assert { x.l < 0. /\ 0. < x.u /\ y.u < 0. };
        (* [x] strictly contains 0 and [y] < 0 *)
        let l_ = if is_pinf x then - large_real else r_dn (x.u / y.u) in
        let u_ = if is_ninf x then large_real else r_up (x.l / y.u) in
        assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                 l_ <= round RTN (xx / yy) };
        assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                 round RTN (xx / yy) < (- max_real) -> l_ = - large_real };
        assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                 u_ >= round RTP (xx / yy) };
        assert { forall xx yy. x.l <= xx -> xx <= x.u -> y.l <= yy -> yy <= y.u ->
                 round RTP (xx / yy) > max_real -> u_ = large_real };

        { l = l_; u = u_; p_nan = x.p_nan || y.p_nan || (is_inf x && is_ninf y) }
      end

    else
      (* [y] contains 0; results in Entire *)
      { l = - large_real; u = large_real;
        p_nan = x.p_nan || y.p_nan || (is_inf x && is_inf y) || (x.l <= 0. && 0. <= x.u) }

end


module Comparison
  use real.Real
  use ieee_float.Float64
  use RealInterval
  use Subtraction

  (* Negative extensions. *)

  predicate gt0_n (f:t)
  = is_pinf f \/ f.u > 0.

  predicate geq0_n (f:t)
  = is_pinf f \/ f.u >= 0.

  predicate gt_n (f g : t)
  = is_pinf f \/ is_ninf g \/ gt0_n (sub_exact f g)

  predicate geq_n (f g : t)
  = is_pinf f \/ is_ninf g \/ geq0_n (sub_exact f g)

  predicate fpeq_n (f g:t)
  = geq_n f g /\ geq_n g f

  predicate eq_n (f g:t)
  = (f.p_nan /\ g.p_nan) \/ fpeq_n f g

  predicate lt0_n (f:t)
  = f.p_nan \/ is_ninf f \/ f.l < 0.

  predicate leq0_n (f:t)
  = f.p_nan \/ is_ninf f \/ f.l <= 0.

  predicate lt_n (f g : t)
  = f.p_nan \/ g.p_nan (*\/ is_ninf f \/ is_pinf g*) \/ lt0_n (sub_exact f g)

  predicate leq_n (f g : t)
  = f.p_nan \/ g.p_nan (*\/ is_ninf f \/ is_pinf g*) \/ leq0_n (sub_exact f g)

  predicate fpneq_n (f g:t)
  = lt_n f g \/ lt_n g f

  predicate neq_n (f g:t)
  = fpneq_n f g

  (* Positive extensions. *)

  predicate gt0_p (f:t)
  = not f.p_nan /\ not (is_ninf f) /\ f.l > 0.

  predicate geq0_p (f:t)
  = not f.p_nan /\ not (is_ninf f) /\ f.l >= 0.

  predicate gt_p (f g : t)
  = not f.p_nan /\ not g.p_nan (*/\ not (is_ninf f) /\ not (is_pinf g)*) /\ 
    gt0_p (sub_exact f g)

  predicate geq_p (f g : t)
  = not f.p_nan /\ not g.p_nan (*/\ not (is_ninf f) /\ not (is_pinf f)*) /\ 
    geq0_p (sub_exact f g)

  predicate fpeq_p (f g : t)
  = not f.p_nan /\ not g.p_nan /\ f.l = f.u /\ f.u = g.l /\ g.l = g.u

  predicate eq_p (f g : t)
  = fpeq_p f g

  predicate lt0_p (f:t)
  = not (is_pinf f) /\ f.u < 0.

  predicate leq0_p (f:t)
  = not (is_pinf f) /\ f.u <= 0.

  predicate lt_p (f g : t)
  = not (is_pinf f) /\ not (is_ninf g) /\ lt0_p (sub_exact f g)

  predicate leq_p (f g : t)
  = not (is_pinf f) /\ not (is_ninf g) /\ leq0_p (sub_exact f g)

  predicate fpneq_p (f g : t)
  = lt_p f g \/ lt_p g f

  predicate neq_p (f g : t)
  = (not f.p_nan \/ not g.p_nan) /\ fpneq_p f g

  (* Auxiliary lemmas. *)

  function ext (v:Float64.t) : t
  = if (t'isFinite v) then { l = t'real v; u = t'real v; p_nan = false }
    else if v .<  zeroF then { l = (- large_real); u = (- large_real); p_nan = false }
    else if v .>= zeroF then { l = large_real;     u = large_real;     p_nan = false }
    else { l = 0.; u = 0.; p_nan = true }

  lemma fp_ext:
    forall ff. fp_in_ri ff (ext ff) /\ ordered (ext ff)

  (* Proof w/ Coq: intros ff. exists (ext f). apply fp_ext. Qed. *)
  lemma fp_ri_exists:
    forall ff. exists f. fp_in_ri ff f /\ ordered f

  (*lemma gt0_n_unsat_: forall f. ordered f -> 
    not (gt0_n f) ->
    forall ff. fp_in_ri ff f -> not (ff .> zeroF)*)

  (* Logical equivalence. *)

  lemma gt_leq: forall f. ordered f ->
    (gt0_n f <-> not leq0_p f)

  lemma geq_lt: forall f. ordered f ->
    (geq0_n f <-> not lt0_p f)

  lemma lt_geq: forall f. ordered f -> 
    (lt0_n f <-> not geq0_p f)

  lemma leq_gt: forall f. ordered f -> 
    (leq0_n f <-> not gt0_p f)

  (* Correctness. *)

  (* [Negative extension (explicit form)]
   * First, prove a slightly lengthy lemma w/ Alt-Ergo. 
   *)
  lemma gt0_n_unsat0: 
    (forall f0. ordered f0 -> not (gt0_n f0)) ->
    forall ff. (exists f. fp_in_ri ff f /\ ordered f) ->
    not (ff .> zeroF)

  (* Then, a shorter lemma can be proved w/ Coq.
   * Proof. intros H ff. apply gt0_n_unsat0. apply H. apply fp_ri_exists. Qed. 
   * In the following, we only describe the lengthy lemmas 
   * for other weak operators. 
   *)
  lemma gt0_n_unsat: 
    (forall f. ordered f -> not (gt0_n f)) ->
    forall ff. not (ff .> zeroF)

  lemma geq0_n_unsat0: 
    (forall f0. ordered f0 -> not (geq0_n f0)) ->
    forall ff. (exists f. fp_in_ri ff f /\ ordered f) ->
    not (ff .>= zeroF)

  (*
  lemma gt_n_unsat: forall f g. ordered f -> ordered g -> not gt_n f g ->
    forall ff gg. fp_in_ri ff f -> fp_in_ri gg g -> not (ff .> gg)

  lemma gt_n_unsat0_: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (gt_n f0 g0)) ->
    forall ff gg. forall f g.
    (fp_in_ri ff f /\ ordered f /\ fp_in_ri gg g /\ ordered g) ->
    not (gt_n f g)

  lemma gt_n_unsat1_: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (gt_n f0 g0)) ->
    forall ff gg. 
    (exists f g. fp_in_ri ff f /\ fp_in_ri gg g /\ ordered f /\ ordered g /\ not (gt_n f g)) ->
    not (ff .> gg)
  *)

  (* [Negative extension (implicit form)]
   *)
  lemma gt_n_unsat0: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (gt_n f0 g0)) ->
    forall ff gg. 
    (exists f g. fp_in_ri ff f /\ fp_in_ri gg g /\ not (gt_n f g)) ->
    not (ff .> gg)

  (* Then, prove a shorter lemma w/ Coq.
   * Proof. intros h1 ff gg. apply gt_n_unsat0. apply h1.
   * exists (ext ff). exists (ext gg). split. 
   * - apply fp_ext.
   * - split. apply fp_ext. apply h1; apply fp_ext.
   * Qed.
   *)
  lemma gt_n_unsat: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (gt_n f0 g0)) ->
    forall ff gg. not (ff .> gg)

  lemma geq_n_unsat0: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (geq_n f0 g0)) ->
    forall ff gg. 
    (exists f g. fp_in_ri ff f /\ fp_in_ri gg g /\ not (geq_n f g)) ->
    not (ff .>= gg)

  lemma fpeq_n_unsat0: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (fpeq_n f0 g0)) ->
    forall ff gg. 
    (exists f g. fp_in_ri ff f /\ fp_in_ri gg g /\ not (fpeq_n f g)) ->
    not (ff .= gg)

  lemma eq_n_unsat0: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (eq_n f0 g0)) ->
    forall ff gg. 
    (exists f g. fp_in_ri ff f /\ fp_in_ri gg g /\ not (eq_n f g)) ->
    not ((is_nan ff /\ is_nan gg) \/ ff .= gg)

  lemma lt0_n_unsat0: 
    (forall f0. ordered f0 -> not (lt0_n f0)) ->
    forall ff. (exists f. fp_in_ri ff f /\ ordered f) ->
    not (not (ff .>= zeroF))

  lemma leq0_n_unsat0: 
    (forall f0. ordered f0 -> not (leq0_n f0)) ->
    forall ff. (exists f. fp_in_ri ff f /\ ordered f) ->
    not (not (ff .> zeroF))

  lemma lt_n_unsat0: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (lt_n f0 g0)) ->
    forall ff gg. 
    (exists f g. fp_in_ri ff f /\ fp_in_ri gg g /\ ordered f /\ ordered g /\ not (lt_n f g)) ->
    not (not (ff .>= gg))

  lemma leq_n_unsat0: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (leq_n f0 g0)) ->
    forall ff gg. 
    (exists f g. fp_in_ri ff f /\ fp_in_ri gg g /\ ordered f /\ ordered g /\ not (leq_n f g)) ->
    not (not (ff .> gg))

  lemma fpneq_n_unsat0: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (fpneq_n f0 g0)) ->
    forall ff gg. 
    (exists f g. fp_in_ri ff f /\ fp_in_ri gg g /\ ordered f /\ ordered g /\ not (fpneq_n f g)) ->
    not (not (ff .= gg))

  lemma neq_n_unsat0: 
    (forall f0 g0. ordered f0 -> ordered g0 -> not (neq_n f0 g0)) ->
    forall ff gg. 
    (exists f g. fp_in_ri ff f /\ fp_in_ri gg g /\ ordered f /\ ordered g /\ not (neq_n f g)) ->
    not (not ((is_nan ff /\ is_nan gg) \/ ff .= gg))


  (* [Positive extensions (explicit form)] 
   * First, prove a variant lemma w/ Alt-Ergo. 
   *)
  lemma gt0_p_sat0: forall f ff. ordered f -> 
    fp_in_ri ff f -> not (ff .> zeroF) -> not (gt0_p f)

  (*lemma gt0_p_sat2: forall f. ordered f -> 
    (exists ff. fp_in_ri ff f /\ not (ff .> zeroF)) ->
    not (gt0_p f)
    *)

  (* Then, prove the soundness claim w/ Alt-Ergo. 
   * In the following, we only describe the variant lemmas 
   * for other strong operators.
   *)
  lemma gt0_p_sat: 
    (forall ff0. not (ff0 .> zeroF)) ->
    forall f. ordered f -> (exists ff. fp_in_ri ff f) -> not (gt0_p f)

  lemma geq0_p_sat0: forall f ff. ordered f -> 
    fp_in_ri ff f -> not (ff .>= zeroF) -> not (geq0_p f)

  (* [Positive extensions (implicit form)] 
   * First, prove a variant lemma w/ Alt-Ergo. 
   *)
  lemma gt_p_sat0: forall f g. ordered f -> ordered g -> 
    forall ff gg. fp_in_ri ff f -> fp_in_ri gg g -> 
    not (ff .> gg) -> not (gt_p f g)

  (* Then, prove the soundness claim w/ Coq. 
   * Proof. intros. apply gt_p_sat0 with (ff:=ff) (gg:=gg); auto. Qed.
   *)
  lemma gt_p_sat: 
    (forall ff0 gg0. not (ff0 .> gg0)) ->
    forall f g. ordered f -> ordered g -> 
    (exists ff gg. fp_in_ri ff f /\ fp_in_ri gg g) -> 
    not (gt_p f g)

  lemma geq_p_sat0: forall f g. ordered f -> ordered g -> 
    forall ff gg. fp_in_ri ff f -> fp_in_ri gg g -> 
    not (ff .>= gg) -> not (geq_p f g)

  lemma fpeq_p_sat0: forall f g. ordered f -> ordered g -> 
    forall ff gg. fp_in_ri ff f -> fp_in_ri gg g -> 
    not (ff .= gg) -> not (fpeq_p f g)

  lemma eq_p_sat0: forall f g. ordered f -> ordered g -> 
    forall ff gg. fp_in_ri ff f -> fp_in_ri gg g -> 
      not ((is_nan ff /\ is_nan gg) \/ ff .= gg) ->
      not (eq_p f g)

  lemma lt0_p_sat0: forall f. ordered f -> 
    forall ff. fp_in_ri ff f -> not (not (ff .>= zeroF)) -> not (lt0_p f)

  lemma leq0_p_sat0: forall f. ordered f -> 
    forall ff. fp_in_ri ff f -> not (not (ff .> zeroF)) -> not (leq0_p f)

  lemma lt_p_sat0: forall f g. ordered f -> ordered g -> 
    forall ff gg. fp_in_ri ff f -> fp_in_ri gg g -> 
    not (not (ff .>= gg)) -> not (lt_p f g)

  lemma leq_p_sat0: forall f g. ordered f -> ordered g -> 
    forall ff gg. fp_in_ri ff f -> fp_in_ri gg g -> 
    not (not (ff .> gg)) -> not (leq_p f g)

  lemma fpneq_p_sat0: forall f g. ordered f -> ordered g -> 
    forall ff gg. fp_in_ri ff f -> fp_in_ri gg g -> 
    not (not (ff .= gg)) -> not (fpneq_p f g)

  lemma neq_p_sat0: forall f g. ordered f -> ordered g -> 
    forall ff gg. fp_in_ri ff f -> fp_in_ri gg g -> 
    not (not ((is_nan ff /\ is_nan gg) \/ ff .= gg)) -> not (neq_p f g)

end
